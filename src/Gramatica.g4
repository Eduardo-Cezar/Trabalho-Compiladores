grammar Gramatica;

inicio: declaracao_func* declaracao_main EOF;
declaracao_main: FUN 'int' 'main' AP FP AC declaracao_vars algoritmo FC;
declaracao_func: FUN TIPO ID AP(TIPO ID)*FP AC declaracao_vars algoritmo FC;
declaracao_vars: (VAR AC (TIPO ID DEL)* FC)?;
chamada_func: CALL FUN ID AP (TIPO ID)* FP DEL;
chamada_funcSemPV: CALL FUN ID AP (TIPO ID)* FP;
acao: entrada_dados | saida_dados | operacao_logica | chamada_func | retorno_de_funcao;
estruturas: repeticao | condicional | atribuicao;
operacao_relacional: (operando) OPREL (operando | operacao_relacional | AP operacao_relacional FP);
operacao_logica: (operando) OPLOGI (operando | operacao_logica | AP operacao_logica FP);
operacao_aritmetica: (operando) OPARIT (operando | AP operacao_aritmetica FP | operacao_aritmetica);
condicional: IF AP (operacao_aritmetica)+ FP AC algoritmo FC;
operando: ID | NUM;
repeticao: WHI AP (operacao_relacional)+ FP AC algoritmo FC;
atribuicao: ID ATR (operacao_aritmetica | ID | CSTR) DEL;
entrada_dados: IN AP (ID) FP DEL;
saida_dados: OUT AP (ID | (operacao_aritmetica)* | chamada_funcSemPV) FP DEL;
algoritmo: (acao | estruturas)*;
retorno_de_funcao: RET (NUM | ID |  CSTR | chamada_funcSemPV) DEL;

AP: '(';
FP: ')';
AC: '{';
FC: '}';
ASP: '"';
DEL: ';';
VAR: 'vars';
ATR: '=';
IN: 'in';
OUT: 'out';
CSTR: ASP(LETRA | DIGITO)*ASP;
TIPO: 'integer' | 'float' | 'boolean' | 'str';
FUN: 'func';
CALL: 'call';
RET: 'return';
OPLOGI: '&&' | '||';
OPARIT: '+' | '-' | '*' | '/';
OPREL: '>' | '<' | '>=' | '<=' | '!=' | '==';
WHI: 'while';
IF: 'if';
THEN: 'then';
ELSE: 'else';
ID: LETRA(DIGITO | LETRA)*;
NUM: DIGITO+('.'DIGITO+)?;
WS: [ \r\t\n]+->skip;
COM: '//' (LETRA | DIGITO | ACENTO | ASP)+->skip;
fragment ACENTO: [A-Za-záàâãéèêíïóôõöúçñÁÀÂÃÉÈÍÏÓÔÕÖÚÇÑ,'"“ ];
fragment LETRA: [a-zA-Z];
fragment DIGITO: [0-9];
